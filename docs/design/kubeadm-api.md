## Kubeadm Phases and API

### Refactoring kubeadm
We all want kubeadm modular and componentized, here’s the proposal for that!
I’m not writing down all reasons for doing this; they are already available in the blog post: https://docs.google.com/document/d/1bpEGhdg8t-2Ae-IL_ezZIPklMHpZLWwnoAPMgLwT3oU

### Phases
We want to identify the phases every single Kubernetes deployment goes through in order to get the cluster up and running.

In this process, I've been thinking a lot about security and tried to put that first. Also, I've read the 
kops, kargo and kube-up code in detail to see how they are doing these things. We don't want to make an API that's incompatible with those tools.

So far (for kubeadm) I've identified these:

#### Certificates

First, certificates should be created in a directory.
There should be:
 - a CA certificate (`ca.pem`) with its private key (`ca-key.pem`)
   - Is the public key necessary to have here (`ca-pub.pem`)?
 - an API Server certificate (`apiserver.pem`) signed with `ca.pem` as the CA with its private key (`apiserver-key.pem`)
 - a Service Account private key that's used for signing Service Accounts' tokens.
   - TODO: Is the certificate for the serviceaccount private key necessary?

Also, we should make sure that both RSA and ECDSA private keys work with kubeadm and have tests for both.
We probably want to expose the private key bitsize also.

One more option that could be useful to many would be to let the user specify their own ca.pem and ca-key.pem, 
and kubeadm would just copy them over to the destination directory and proceed as usual. This might be beneficial to orgs
that require a specific CA but lets the apiserver and serviceaccount keys/certs be generated by kubeadm.

**Inputs**
 - `AdvertiseAddresses` is needed for knowing which IPs the certs should be signed for
 - `ExternalDNSNames` is needed for knowing which DNS names the certs should be signed for
 - `DNSDomain` is needed for knowing which DNS name the internal kubernetes service has
 - `ServiceSubnet` is needed for knowing which IP the internal kubernetes service is going to point to
 - `CertificatesDir` is required for knowing where all certificates should be stored

**Outputs**
 - Files in directory `CertificatesDir`:
   - `ca.pem`
   - `ca-key.pem`
   - `apiserver.pem`
   - `apiserver-key.pem`
   - ?`sa.pem`?
   - `sa-key.pem`


#### Generate KubeConfig files for the admin and the kubelet on the master

The second phase takes the certificates generated in phase 1 and the public master endpoint as input and produces two kubeconfig files,
`admin.conf` and `kubelet.conf` in `/etc/kubernetes/` by default.

A general question here, do we want the KubernetesDir to be configurable at all or does it only add complexity/confusion if a user ever changed that path?
I lean towards having that as a constant, since that seems to be the case with a lot of other deployments and the gain is very small.

There also is the question whether this phase should generate both the kubelet and the admin config. Or should those be two different phases/steps?
How can we make the kubelet have just a little permissions but still use it for bootstrapping the api server? Can start the master ("bootstrap") kubelet with full access, 
then do the CSR dance and swap the kubeconfig later on the fly?

**Inputs**
 - `CertificatesDir` is required for knowing where all certificates are stored
 - `MasterEndpoint` is needed for knowing where to find the API Server (servers if using a DNS endpoint)
 - `KubernetesDir` is needed for knowing where to put the kubeconfig files. Should be constant or not?

**Outputs**
 - Files in directory `KubernetesDir`:
   - `admin.conf`
   - `kubelet.conf`

#### Bring up the control plane

TODO

#### Configure the API Server

TODO
Add users, configmaps, taints etc.

#### Setup Discovery

TODO

#### Bring up addons

TODO

In particular, kube-dns and kube-proxy

Use `--kubernetes-service-node-port` here and let the kube-proxy use the built-in SA certs?


### Proposed API types with respect to the information above

```go
type MasterConfiguration struct {
	metav1.TypeMeta `json:",inline"`

	// Data shared between phases
	Master     Master     `json:"master"`
	Networking Networking `json:"networking"`

	// Phases
	Certificates   Certificates   `json:"certificates"`
	MakeKubeConfig MakeKubeConfig `json:"makeKubeConfig"`
	Discovery      Discovery      `json:"discovery"`
}

type Phase struct {
	Annotations map[string]string `json:"annotations"`
	Enabled     bool              `json:"enabled"`
}

// Shared
// TODO: This field should be HA friendly
type Master struct {
	// Only the first address here will be passed to the api-server. The rest will be used for signing CA certs.
	// This is not great with HA, because can't
	AdvertiseAddresses []string `json:"advertiseAddresses"`
	// Used for signing the certs
	ExternalDNSNames []string `json:"externalDNSNames"`
	// For the controlplane phase
	Port int32 `json:"port"`
}

type Networking struct {
	ServiceSubnet string `json:"serviceSubnet"`
	PodSubnet     string `json:"podSubnet"`
	DNSDomain     string `json:"dnsDomain"`
}

type Paths struct {
	CertificatesDir string `json:"certificatesDir"`

	// TODO: Maybe have as a constant?
	KubernetesDir   string `json:"kubernetesDir"`
}

// Phases with their subtypes
type Certificates struct {
	Phase Phase `json:"phase"`

	SelfSign *SelfSignCertificates `json:"selfSign"`
}

type SelfSignCertificates struct {
	// Needs Master, Networking and Paths

	// For example, let the user choose key type
	// Can be RSA or ECDSA?
	PrivateKeyFormat string `json:"privateKeyFormat"`
	KeySize          uint16 `json:"keySize"`

	CACertPath          string `json:"caCertPath"`
	CAKeyPath          string `json:"caKeyPath"`
}

type MakeKubeConfig struct {
	Phase Phase `json:"phase"`

	MasterDefault *MasterDefaultKubeConfig `json:"masterDefault"`
}

// TODO: Decide whether this phase should generate both for kubelet and admin.
// This phase is probably useful generally for creating kubeconfigs from certificates
type MasterDefaultKubeConfig struct {
	CertificatesDir string   `json:"certificatesDir"`


	AdminConfigPath   string   `json:"adminConfigPath"`

	// We should be able to generate this KubeConfig file in the same manner as we do on nodes, so the master kubelets don't
	// have full access to the apiserver while the node kubelet would have limited access, which is a thing we should do later.
	KubeletConfigPath   string   `json:"kubeletConfigPath"`

	// This could be a []string in the API, but initially only support a string before KubeConfig itself supports multiple endpoints.
	MasterEndpoint  []string `json:"masterEndpoint"`
}

type ControlPlane struct {
	Phase Phase `json:"phase"`

	Version           string `json:"version"`
	ImageRepository   string `json:"imageRepository"`
	UseHyperkubeImage string `json:"useHyperkubeImage"`

	CloudProvider string `json:"cloudProvider"`

	Etcd Etcd `json:"etcd"`

	// TODO: We want to use ComponentConfig here
	ExtraArguments ComponentExtraList `json:"extraArguments"`
	ExtraHostPathVolumes ComponentExtraList `json:"extraHostPathVolumes"`

	StaticPod  *StaticPodControlPlane  `json:"staticPod"`
	SelfHosted *SelfHostedControlPlane `json:"selfHosted"`
}

type StaticPodControlPlane struct {
	Dummy string
}

type SelfHostedControlPlane struct {
	Dummy string
}

type ComponentExtraList struct {
	APIServer []string `json:"apiServer"`
	ControllerManager []string `json:"controllerManager"`
	Scheduler []string `json:"scheduler"`
}


type Etcd struct {
	External *ExternalEtcd `json:"external"`
	Local    *LocalEtcd    `json:"local"`
}

type ExternalEtcd struct {
	Endpoints []string `json:"endpoints"`
	CAFile    string   `json:"caFile"`
	CertFile  string   `json:"certFile"`
	KeyFile   string   `json:"keyFile"`
}

type LocalEtcd struct {
	DataDir string `json:"dataDir"`
}

type Discovery struct {
	Phase Phase           `json:"phase"`

	HTTPS *HTTPSDiscovery `json:"https"`
	File  *FileDiscovery  `json:"file"`
	Token *TokenDiscovery `json:"token"`
}

type HTTPSDiscovery struct {
	URL string `json:"url"`
}

type FileDiscovery struct {
	Path string `json:"path"`
}

type TokenDiscovery struct {
	ID        string   `json:"id"`
	Secret    string   `json:"secret"`
	Addresses []string `json:"addresses"`
}

type APIConfiguration struct {
	Phase Phase `json:"phase"`

	KubeConfigFile string `json:"kubeConfigFile"`

	KubeSystemConfigMaps map[string]string `json:"kubeSystemConfigMaps"`
}

type Addons struct {
	Phase Phase `json:"phase"`

	KubeConfigFile string `json:"kubeConfigFile"`

	ImageRepository   string `json:"imageRepository"`

	ApplyManifests []string `json:"applyManifests"`
}

type NodeConfiguration struct {
	metav1.TypeMeta `json:",inline"`

	Discovery Discovery `json:"discovery"`
}
```
